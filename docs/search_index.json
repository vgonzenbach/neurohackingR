[
["index.html", "08-normalization Introduction", " 08-normalization Virgilio Gonzenbach 2020-06-05 Introduction This bookdown book contains my own lecture notes and edited scripts from the Coursera class, Introduction to Neurohacking in R. "],
["dicom.html", "Lecture 1 DICOM 1.1 readDICOM Output 1.2 DICOM Images 1.3 DICOM Header Information 1.4 Loading Multiple DICOM Files 1.5 Summary", " Lecture 1 DICOM DICOM (Digital Imaging and Communications in Medicine) format Standardized representation of images Formats of files from scanner to hospital PACS (picture archiving and communication system) Two components: image data (in pixles) and header (metadata) 1.1 readDICOM Output The pixel data in a DICOM file is a matrix One DICOM file = one \"slice of the brain The oro.dicom package enables reading DICOM files in R. Each slice is stored as a list. library(oro.dicom) ## oro.dicom 0.5.3 slice = readDICOM(&quot;Neurohacking_data/BRAINIX/DICOM/FLAIR/IM-0001-0011.dcm&quot;) suppressMessages(class(slice)) ## [1] &quot;list&quot; This contains two lists: hdr and img names(slice) ## [1] &quot;hdr&quot; &quot;img&quot; class(slice$hdr) ## [1] &quot;list&quot; class(slice$img) ## [1] &quot;list&quot; Each element of hdr is a data.frame and each element of img is a matrix class(slice$hdr[[1]]) ## [1] &quot;data.frame&quot; class(slice$img[[1]]) ## [1] &quot;matrix&quot; dim(slice$img[[1]]) ## [1] 288 288 1.2 DICOM Images We can look at the image in R. d = dim(t(slice$img[[1]])) image(1:d[1], 1:d[2], t(slice$img[[1]]), col=gray(0:64/64)) For analysis we want to look at the numbers in the matrix, not the image in the grayscale. 1.2.1 Working with the numbers slice$img[[1]][101:105, 121:125] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 4 34 36 75 222 ## [2,] 9 44 33 117 248 ## [3,] 19 47 54 167 274 ## [4,] 27 28 98 239 286 ## [5,] 12 45 170 288 307 And we can plot the data as usual using histograms hist(slice$img[[1]][,], #all elements breaks=50, xlab=&quot;FLAIR&quot;, prob=T, col = rgb(0, 0, 1, 1/4), main=&quot;&quot;) 1.3 DICOM Header Information Now let’s look at the header. hdr = slice$hdr[[1]] str(hdr) ## &#39;data.frame&#39;: 162 obs. of 7 variables: ## $ group : chr &quot;0002&quot; &quot;0002&quot; &quot;0002&quot; &quot;0002&quot; ... ## $ element : chr &quot;0000&quot; &quot;0001&quot; &quot;0002&quot; &quot;0003&quot; ... ## $ name : chr &quot;GroupLength&quot; &quot;FileMetaInformationVersion&quot; &quot;MediaStorageSOPClassUID&quot; &quot;MediaStorageSOPInstanceUID&quot; ... ## $ code : chr &quot;UL&quot; &quot;OB&quot; &quot;UI&quot; &quot;UI&quot; ... ## $ length : chr &quot;4&quot; &quot;2&quot; &quot;26&quot; &quot;62&quot; ... ## $ value : chr &quot;210&quot; &quot;\\001&quot; &quot;1.2.840.10008.5.1.4.1.1.4&quot; &quot;1.3.46.670589.11.0.0.11.4.2.0.8743.5.5396.2006120114313982544&quot; ... ## $ sequence: chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... Each row of the dataframe has a name: hdr$name ## [1] &quot;GroupLength&quot; ## [2] &quot;FileMetaInformationVersion&quot; ## [3] &quot;MediaStorageSOPClassUID&quot; ## [4] &quot;MediaStorageSOPInstanceUID&quot; ## [5] &quot;TransferSyntaxUID&quot; ## [6] &quot;ImplementationClassUID&quot; ## [7] &quot;ImplementationVersionName&quot; ## [8] &quot;SourceApplicationEntityTitle&quot; ## [9] &quot;SpecificCharacterSet&quot; ## [10] &quot;ImageType&quot; ## [11] &quot;InstanceCreationDate&quot; ## [12] &quot;InstanceCreationTime&quot; ## [13] &quot;InstanceCreatorUID&quot; ## [14] &quot;SOPClassUID&quot; ## [15] &quot;SOPInstanceUID&quot; ## [16] &quot;StudyDate&quot; ## [17] &quot;SeriesDate&quot; ## [18] &quot;AcquisitionDate&quot; ## [19] &quot;ContentDate&quot; ## [20] &quot;StudyTime&quot; ## [21] &quot;SeriesTime&quot; ## [22] &quot;AcquisitionTime&quot; ## [23] &quot;ContentTime&quot; ## [24] &quot;AccessionNumber&quot; ## [25] &quot;Modality&quot; ## [26] &quot;Manufacturer&quot; ## [27] &quot;InstitutionName&quot; ## [28] &quot;ReferringPhysiciansName&quot; ## [29] &quot;StationName&quot; ## [30] &quot;StudyDescription&quot; ## [31] &quot;ProcedureCodeSequence&quot; ## [32] &quot;Item&quot; ## [33] &quot;CodeValue&quot; ## [34] &quot;CodingSchemeDesignator&quot; ## [35] &quot;CodeMeaning&quot; ## [36] &quot;ContextGroupExtensionFlag&quot; ## [37] &quot;ItemDelimitationItem&quot; ## [38] &quot;SequenceDelimitationItem&quot; ## [39] &quot;SeriesDescription&quot; ## [40] &quot;InstitutionalDepartmentName&quot; ## [41] &quot;ManufacturersModelName&quot; ## [42] &quot;ReferencedStudySequence&quot; ## [43] &quot;Item&quot; ## [44] &quot;ReferencedSOPClassUID&quot; ## [45] &quot;ReferencedSOPInstanceUID&quot; ## [46] &quot;ItemDelimitationItem&quot; ## [47] &quot;SequenceDelimitationItem&quot; ## [48] &quot;ReferencedPerformedProcedureStepSequence&quot; ## [49] &quot;Item&quot; ## [50] &quot;InstanceCreationDate&quot; ## [51] &quot;InstanceCreationTime&quot; ## [52] &quot;InstanceCreatorUID&quot; ## [53] &quot;ReferencedSOPClassUID&quot; ## [54] &quot;ReferencedSOPInstanceUID&quot; ## [55] &quot;InstanceNumber&quot; ## [56] &quot;ItemDelimitationItem&quot; ## [57] &quot;SequenceDelimitationItem&quot; ## [58] &quot;ReferencedImageSequence&quot; ## [59] &quot;Item&quot; ## [60] &quot;ReferencedSOPClassUID&quot; ## [61] &quot;ReferencedSOPInstanceUID&quot; ## [62] &quot;ItemDelimitationItem&quot; ## [63] &quot;Item&quot; ## [64] &quot;ReferencedSOPClassUID&quot; ## [65] &quot;ReferencedSOPInstanceUID&quot; ## [66] &quot;ItemDelimitationItem&quot; ## [67] &quot;Item&quot; ## [68] &quot;ReferencedSOPClassUID&quot; ## [69] &quot;ReferencedSOPInstanceUID&quot; ## [70] &quot;ItemDelimitationItem&quot; ## [71] &quot;SequenceDelimitationItem&quot; ## [72] &quot;PatientsName&quot; ## [73] &quot;PatientID&quot; ## [74] &quot;PatientsBirthDate&quot; ## [75] &quot;PatientsSex&quot; ## [76] &quot;PatientsWeight&quot; ## [77] &quot;PregnancyStatus&quot; ## [78] &quot;ScanningSequence&quot; ## [79] &quot;SequenceVariant&quot; ## [80] &quot;SliceThickness&quot; ## [81] &quot;RepetitionTime&quot; ## [82] &quot;EchoTime&quot; ## [83] &quot;InversionTime&quot; ## [84] &quot;NumberOfAverages&quot; ## [85] &quot;ImagingFrequency&quot; ## [86] &quot;ImagedNucleus&quot; ## [87] &quot;EchoNumbers&quot; ## [88] &quot;MagneticFieldStrength&quot; ## [89] &quot;SpacingBetweenSlices&quot; ## [90] &quot;NumberOfPhaseEncodingSteps&quot; ## [91] &quot;EchoTraInLength&quot; ## [92] &quot;PercentSampling&quot; ## [93] &quot;PercentPhaseFieldOfView&quot; ## [94] &quot;DeviceSerialNumber&quot; ## [95] &quot;SoftwareVersions&quot; ## [96] &quot;ProtocolName&quot; ## [97] &quot;LowRRValue&quot; ## [98] &quot;HighRRValue&quot; ## [99] &quot;IntervalsAcquired&quot; ## [100] &quot;IntervalsRejected&quot; ## [101] &quot;HeartRate&quot; ## [102] &quot;ReconstructionDiameter&quot; ## [103] &quot;ReceiveCoilName&quot; ## [104] &quot;TransmitCoilName&quot; ## [105] &quot;AcquisitionMatrix&quot; ## [106] &quot;InPlanePhaseEncodingDirection&quot; ## [107] &quot;FlipAngle&quot; ## [108] &quot;PatientPosition&quot; ## [109] &quot;StudyInstanceUID&quot; ## [110] &quot;SeriesInstanceUID&quot; ## [111] &quot;StudyID&quot; ## [112] &quot;SeriesNumber&quot; ## [113] &quot;AcquisitionNumber&quot; ## [114] &quot;InstanceNumber&quot; ## [115] &quot;ImagePositionPatient&quot; ## [116] &quot;ImageOrientationPatient&quot; ## [117] &quot;FrameOfReferenceUID&quot; ## [118] &quot;TemporalPositionIdentifier&quot; ## [119] &quot;NumberOfTemporalPositions&quot; ## [120] &quot;SliceLocation&quot; ## [121] &quot;SamplesperPixel&quot; ## [122] &quot;PhotometricInterpretation&quot; ## [123] &quot;Rows&quot; ## [124] &quot;Columns&quot; ## [125] &quot;PixelSpacing&quot; ## [126] &quot;PixelAspectRatio&quot; ## [127] &quot;BitsAllocated&quot; ## [128] &quot;BitsStored&quot; ## [129] &quot;HighBit&quot; ## [130] &quot;PixelRepresentation&quot; ## [131] &quot;WindowCenter&quot; ## [132] &quot;WindowWidth&quot; ## [133] &quot;LossyImageCompression&quot; ## [134] &quot;RequestingService&quot; ## [135] &quot;RequestedProcedureDescription&quot; ## [136] &quot;PerformedStationAETitle&quot; ## [137] &quot;PerformedProcedureStepStartDate&quot; ## [138] &quot;PerformedProcedureStepStartTime&quot; ## [139] &quot;PerformedProcedureStepEndDate&quot; ## [140] &quot;PerformedProcedureStepEndTime&quot; ## [141] &quot;PerformedProcedureStepID&quot; ## [142] &quot;PerformedProcedureStepDescription&quot; ## [143] &quot;PerformedProtocolCodeSequence&quot; ## [144] &quot;Item&quot; ## [145] &quot;CodeValue&quot; ## [146] &quot;CodingSchemeDesignator&quot; ## [147] &quot;CodeMeaning&quot; ## [148] &quot;ContextGroupExtensionFlag&quot; ## [149] &quot;ItemDelimitationItem&quot; ## [150] &quot;SequenceDelimitationItem&quot; ## [151] &quot;RequestAttributesSequence&quot; ## [152] &quot;Item&quot; ## [153] &quot;ScheduledProcedureStepDescription&quot; ## [154] &quot;ScheduledProcedureStepID&quot; ## [155] &quot;RequestedProcedureID&quot; ## [156] &quot;ItemDelimitationItem&quot; ## [157] &quot;SequenceDelimitationItem&quot; ## [158] &quot;FilmConsumptionSequence&quot; ## [159] &quot;SequenceDelimitationItem&quot; ## [160] &quot;RequestedProcedureID&quot; ## [161] &quot;PresentationLUTShape&quot; ## [162] &quot;PixelData&quot; Let’s look at the \"PixelSpacing\" for this images, which represents the resolution of the image. hdr[hdr$name == &#39;PixelSpacing&#39;, &#39;value&#39;] ## [1] &quot;0.79861110448837 0.79861110448837&quot; We can also look at the Flip Angle used while collecting the image. hdr[hdr$name == &#39;FlipAngle&#39;, ] ## group element name code length value sequence ## 107 0018 1314 FlipAngle DS 4 90.0 1.4 Loading Multiple DICOM Files For analysis, we will need to read in all the slices. Specifying a directory instead of a file name in readDICOM will load all images in that directory as a single object. all_slices_T1 = readDICOM(&quot;Neurohacking_data/BRAINIX/DICOM/T1/&quot;) Examining the dimensions of the first slice shows that the T1 image has a higher resolution than the FLAIR image. Thus this is a bigger dim(all_slices_T1$img[[1]]) ## [1] 512 512 hdr = all_slices_T1$hdr[[1]] hdr[hdr$name == &quot;PixelSpacing&quot;, &quot;value&quot;] ## [1] &quot;0.46875 0.46875&quot; 1.5 Summary -DICOM files contain a lot of information -Image data are stored as collection of 2D slice files -Different sequences can have different resolutions -Data and metadata can be accessed in R -Contains protected health data -Structure is cumbersome for 3D analysis -A genuine 3D format is needed:: NIfTI "],
["nifti.html", "Lecture 2 NIfTI 2.1 From DICOM to NIfTI 2.2 Write and Read NIfTI files 2.3 Compressed Image Files", " Lecture 2 NIfTI NifTI (Neuroimaging Informatics Tehcnology Image) -Standardized representation of images -Most commonly used tpy eof analytic file -Developed to facilitate cross-platform, cross-software interpretability -3-dimensional array: stacking individual slices on top of each other -DICOM: one sheet of paper; NIfTI: stack of papers 2.1 From DICOM to NIfTI -DICOM to NIFTI using the dicom2nifti function in the oro.dicom package -The nifti object becomes an R object -After saving a file to a nifti file it can be used without R Let’s read all DICOM images: library(oro.dicom) ## oro.dicom 0.5.3 all_slices_T1 = readDICOM(&quot;Neurohacking_data/BRAINIX/DICOM/T1&quot;) dim(all_slices_T1$img[[11]]) ## [1] 512 512 hdr = all_slices_T1$hdr[[11]] hdr[hdr$name == &quot;PixelSpacing&quot;, &quot;value&quot;] ## [1] &quot;0.46875 0.46875&quot; Now lets’s convert them to NIFTI: nii_T1 = dicom2nifti(all_slices_T1) ## Warning in create3D(dcm, ...): ImagePositionPatient is moving in more than one ## dimension. ## Warning in swapDimension(img, dcm): Oblique acquisition in ## ImageOrientationPatient (hope for the best). ## Warning in is.axial(imageOrientationPatient): Oblique acquisition in ## ImageOrientationPatient. ## Warning in is.coronal(imageOrientationPatient): Oblique acquisition in ## ImageOrientationPatient. ## Warning in is.sagittal(imageOrientationPatient): Oblique acquisition in ## ImageOrientationPatient. d = dim(nii_T1); d; class(nii_T1) ## [1] 512 512 22 ## [1] &quot;nifti&quot; ## attr(,&quot;package&quot;) ## [1] &quot;oro.nifti&quot; And plot one slice: # Plot the 11th slice image(1:d[1], 1:d[2], nii_T1[,,11], col=gray(0:64/64), xlab=&quot;&quot;, ylab=&quot;&quot;) 2.2 Write and Read NIfTI files Use the writeNIfTI, readNIfTI functions in the oro.nifti package Default for writeNIfTI is to save the compressed NIfTI files library(oro.nifti) ## oro.nifti 0.10.1 dir_name = &quot;Neurohacking_data/BRAINIX/NIfTI/&quot; fname = &quot;Output_3D_File&quot; writeNIfTI(nim=nii_T1, file = paste0(dir_name, fname)) And check that the file si there after saving list.files(dir_name, pattern = fname) ## [1] &quot;Output_3D_File.nii.gz&quot; Now lets read a different file: list.files(dir_name, pattern=&quot;T&quot;) #Check that file is in directory ## [1] &quot;T1.nii.gz&quot; &quot;T2.nii.gz&quot; nii_T2=readNIfTI(paste0(dir_name,&quot;T2.nii.gz&quot;), reorient=FALSE) dim(nii_T2) ## [1] 512 512 22 2.3 Compressed Image Files -A non-compressed file can be obtained using the argument gzipped=FALSE in the function writeNIfTI "],
["basic-visualization.html", "Lecture 3 Basic Visualization 3.1 Read NIfTI 3.2 Visualizing Slices 3.3 Exploratory histogram of intensities 3.4 Back mapping", " Lecture 3 Basic Visualization This lecture goes over basic visualization methods. Objectives are the following: -Visualize Slices -Digital Zoom -Histograms of Intensities -Back mapping 3.1 Read NIfTI library(oro.nifti) ## oro.nifti 0.10.1 dir = &quot;Neurohacking_data/BRAINIX/NIfTI/&quot; fname = &quot;Output_3D_File&quot; fpath = paste0(dir,fname) (nii_T1 = readNIfTI(fname = fpath)) ## NIfTI-1 format ## Type : nifti ## Data Type : 4 (INT16) ## Bits per Pixel : 16 ## Slice Code : 0 (Unknown) ## Intent Code : 0 (None) ## Qform Code : 2 (Aligned_Anat) ## Sform Code : 2 (Aligned_Anat) ## Dimension : 512 x 512 x 22 ## Pixel Dimension : 0.47 x 0.47 x 5 ## Voxel Units : mm ## Time Units : sec Printing the NIfTI object show the structure of the data 3.2 Visualizing Slices As a first pass, we could use the image function from the graphics package. #Save dimensions of the image d = dim(nii_T1) # Visualizing the 11th axial slice graphics::image(1:d[1], 1:d[2], nii_T1[,,11], col = gray(0:64/64), xlab=&quot;&quot;, ylab=&quot;&quot;) However, oro.nifti has its own image function which is called by default one NIfTI objects. image(nii_T1, z = 11, plot.type = &quot;single&quot;) If no arguments are passed for coordinates, oro.nifti::image plots all the slices axially. image(nii_T1) The orthographic functions allows to visualize a single point from three dimensions. orthographic(nii_T1, xyz = c(200,220,11)) 3.3 Exploratory histogram of intensities Using R base graphics, we can get a quick view of the intensites in the brain. par(mfrow = c(1, 2)); o = par(mar = c(4,4,0,0)) hist(nii_T1, breaks = 75, prob = T, xlab=&quot;T1 intensities&quot;, col = rgb(0,0,1, 1/2), main=&quot;&quot;) # Plot filtered by &gt; 20 hist(nii_T1[nii_T1 &gt; 20], breaks = 75, prob = T, xlab=&quot;T1 intensities &gt; 20&quot;, col = rgb(0,0,1, 1/2), main=&quot;&quot; ) A lot ot the voxels, are ~0 in the first plot since most of the image is the black background. The second plot shows the intensities that are higher than 20. 3.4 Back mapping Backmapping consists of overlaying a mask over an image of the brain. A basic backmapping can be achieved by taking creating a mask according to intensities and calling the function overlay. is_btw_300_400 = nii_T1 &gt; 300 &amp; nii_T1 &lt; 400 nii_T1_mask = nii_T1 nii_T1_mask[!is_btw_300_400] = NA overlay(nii_T1, nii_T1_mask, z = 11, plot.type=&quot;single&quot;) overlay can be called to show a single slice as above, or the whole brain as below. overlay(nii_T1, nii_T1_mask) orthographic(nii_T1, nii_T1_mask, xyz=c(200,220,11), text=&quot;Image overlaid with a mask&quot;, text.cex = 1.5) ## Warning in min(x, na.rm = na.rm): no non-missing arguments to min; returning Inf ## Warning in max(x, na.rm = na.rm): no non-missing arguments to max; returning - ## Inf "],
["data-manipulation.html", "Lecture 4 Data Manipulation 4.1 Open data 4.2 Visualization 4.3 Masking 4.4 Substraction", " Lecture 4 Data Manipulation This lecture covers: - Masking - Operations 4.1 Open data The code below downloads opens the T1-weighted image and downloads the mask for this data. fname = &quot;113-01-MPRAGE.nii.gz&quot; fpath = file.path(&quot;Neurohacking_data/kirby21/visit_1/113&quot;, fname) maskurl = &quot;https://raw.githubusercontent.com/muschellij2/Neurohacking/master/Basic_Data_Manipulations/Kirby21/SUBJ0001_mask.nii.gz&quot; maskfname = &quot;SUBJ0001_mask.nii.gz&quot; maskfpath = file.path(&quot;Neurohacking_data&quot;, maskfname) download.file(maskurl, maskfpath, mode=&quot;wb&quot;)# NIfTI is binaryfile format library(oro.nifti) T1 = readNIfTI(fpath,reorient=FALSE) mask = readNIfTI(maskfpath, reorient=FALSE) 4.2 Visualization This brain was collected with a bigger FOV than the previous scans. Thus a lot of body parts other than brain are shown. orthographic(T1) orthographic(mask) 4.3 Masking masked.T1 = T1*mask orthographic(masked.T1) 4.4 Substraction fname = &quot;113-02-MPRAGE.nii.gz&quot; fpath = file.path(&quot;Neurohacking_data/kirby21/visit_2/113&quot;, fname) T1.follow = readNIfTI(fpath, reorient = FALSE) substract.T1 = T1.follow - T1 min(substract.T1) ## [1] -1810405 max(substract.T1) ## [1] 2054726 orthographic(substract.T1) "],
["transformation.html", "Lecture 5 Transformation 5.1 Visualizing after transformations 5.2 Smoothing", " Lecture 5 Transformation fname = &quot;SUBJ0001-01-MPRAGE.nii.gz&quot; fpath = file.path(&quot;Neurohacking_data/kirby21&quot;, fname) library(oro.nifti) ## oro.nifti 0.10.1 T1 = readNIfTI(fpath,reorient=FALSE) im_hist = hist(T1, plot=FALSE) par(mar = c(5, 4, 4, 4) + 0.3) col1 = rgb(0,0,1,1/2) plot(im_hist$mids, im_hist$count, log=&quot;y&quot;, type=&quot;h&quot;, lwd=10, lend=2, col=col1, xlab=&quot;Intensity Values&quot;, ylab=&quot;Count (Log Scale)&quot;) ## Warning in xy.coords(x, y, xlabel, ylabel, log): 2 y values &lt;= 0 omitted from ## logarithmic plot par(new = TRUE) curve(x*1, axes = FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, col=2, lwd=3) axis(side=4, at =pretty(range(im_hist$mids))/max(T1), labels=pretty(range(im_hist$mids))) mtext(&quot;Original Intensity&quot;, side=4, line=2) #Define a linear spline function lin.sp = function(x, knots, slope){ knots = c(min(x), knots, max(x)) slopeS = slope[1] for(j in 2:length(slope)){ slopeS = c(slopeS, slope[j]-sum(slopeS)) } rvals = numeric(length(x)) for(i in 2:length(knots)){ rvals = ifelse(x &gt;= knots[i-1], slopeS[i-1]*(x-knots[i-1])+rvals, rvals) } return(rvals) } #Define a linear spline knot.vals = c(.3,.6) slp.vals = c(1, .5, .25) #Repeat the histgram par(mar = c(5, 4, 4, 4) + 0.3) plot(im_hist$mids, im_hist$count, log=&quot;y&quot;, type=&quot;h&quot;, lwd=10, lend=2, col=col1, xlab=&quot;Intensity Values&quot;, ylab=&quot;Count (Log Scale)&quot;) ## Warning in xy.coords(x, y, xlabel, ylabel, log): 2 y values &lt;= 0 omitted from ## logarithmic plot #Change curve() to graph linear pline par(new = TRUE) curve(lin.sp(x, knot.vals, slp.vals), axes=FALSE, xlab=&quot;&quot;, ylab=&quot;&quot;, col=2, lwd=3) axis(side=4, at =pretty(range(im_hist$mids))/max(T1), labels=pretty(range(im_hist$mids))) mtext(&quot;Transformed Intensity&quot;, side=4, line=2) You can define different types of transfer functions. 5.1 Visualizing after transformations knot.vals = c(.3,.6) slp.vals = c(1, .5, .25) trans_T1 = lin.sp(T1, knot.vals*max(T1), slp.vals) par(mfrow = c(1, 2)) image(T1, z=150, plot.type=&#39;single&#39;, main=&quot;Original Image&quot;) image(trans_T1, z=150, plot.type=&#39;single&#39;, main=&quot;Transformed Image&quot;) Notes -Knots rescaled to the cale of intensities knots.vals*max(T1) -The transfer function can be any functions -Used for better: -visualization -prediction -input into standard software 5.2 Smoothing library(AnalyzeFMRI) ## Loading required package: R.matlab ## R.matlab v3.6.2 (2018-09-26) successfully loaded. See ?R.matlab for help. ## ## Attaching package: &#39;R.matlab&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## getOption, isOpen ## Loading required package: fastICA ## Loading required package: tcltk ## Loading required package: tkrplot smooth.T1 = GaussSmoothArray(T1, voxdim = c(1,1,1), ksize=11, sigma=diag(3,3), mask = NULL, var.norm = FALSE ) orthographic(smooth.T1) "],
["inhomogeneitybias-field-correction.html", "Lecture 6 Inhomogeneity/Bias Field Correction 6.1 Some statistics using FSL 6.2 Perform inhomogeneity correction 6.3 Plot difference between images in R 6.4 Plotting histograms of intensities for original and bias-corrected images 6.5 Write NIfTi", " Lecture 6 Inhomogeneity/Bias Field Correction #set fsl path before running fslr in RStudio library(fslr) if(!have.fsl()){ options(fsl.path = &#39;/usr/local/bin&#39;) } #Check file paths for data downloaded from library(oro.nifti) fpath = &quot;Neurohacking_data/kirby21/visit_1/113&quot; fname = &quot;113-01-MPRAGE&quot; nim = readNIfTI(file.path(fpath,fname), reorient=FALSE) 6.1 Some statistics using FSL mean(nim) ## [1] 143789.2 # can call fsl within r on the &#39;nim&#39; img fslstats(nim, opts=&quot;-m&quot;) ## FSLDIR=&#39;/usr/local/fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats &quot;/private/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T/Rtmp3GNcsB/file2abfa28b34.nii.gz&quot; -m ## [1] &quot;143789.231769&quot; # can also provide a filepath instead of r object fslstats(fpath, opts=&quot;-m&quot;) ## FSLDIR=&#39;/usr/local/fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats &quot;/Users/vgonzenb/R/neurohackingcoursera/Neurohacking_data/kirby21/visit_1/113&quot; -m ## Warning in system(cmd, intern = TRUE): running command &#39;FSLDIR=&#39;/usr/local/ ## fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/ ## fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fslstats &quot;/ ## Users/vgonzenb/R/neurohackingcoursera/Neurohacking_data/kirby21/visit_1/113&quot; -m&#39; ## had status 255 ## character(0) ## attr(,&quot;status&quot;) ## [1] 255 fslstats.help() ## Usage: fslstats [preoptions] &lt;input&gt; [options]preoption -t will give a separate output line for each 3D volume of a 4D timeseriespreoption -K &lt; indexMask &gt; will generate seperate n submasks from indexMask, for indexvalues 1..n where n is the maximum index value in indexMask, and generate statistics for each submaskNote - options are applied in order, e.g. -M -l 10 -M will report the non-zero mean, apply a threshold and then report the new nonzero mean-l &lt;lthresh&gt; : set lower threshold-u &lt;uthresh&gt; : set upper threshold-r : output &lt;robust min intensity&gt; &lt;robust max intensity&gt;-R : output &lt;min intensity&gt; &lt;max intensity&gt;-e : output mean entropy ; mean(-i*ln(i))-E : output mean entropy (of nonzero voxels)-v : output &lt;voxels&gt; &lt;volume&gt;-V : output &lt;voxels&gt; &lt;volume&gt; (for nonzero voxels)-m : output mean-M : output mean (for nonzero voxels)-s : output standard deviation-S : output standard deviation (for nonzero voxels)-w : output smallest ROI &lt;xmin&gt; &lt;xsize&gt; &lt;ymin&gt; &lt;ysize&gt; &lt;zmin&gt; &lt;zsize&gt; &lt;tmin&gt; &lt;tsize&gt; containing nonzero voxels-x : output co-ordinates of maximum voxel-X : output co-ordinates of minimum voxel-c : output centre-of-gravity (cog) in mm coordinates-C : output centre-of-gravity (cog) in voxel coordinates-p &lt;n&gt; : output nth percentile (n between 0 and 100)-P &lt;n&gt; : output nth percentile (for nonzero voxels)-a : use absolute values of all image intensities-n : treat NaN or Inf as zero for subsequent stats-k &lt;mask&gt; : use the specified image (filename) for masking - overrides lower and upper thresholds-d &lt;image&gt; : take the difference between the base image and the image specified here-h &lt;nbins&gt; : output a histogram (for the thresholded/masked voxels only) with nbins-H &lt;nbins&gt; &lt;min&gt; &lt;max&gt; : output a histogram (for the thresholded/masked voxels only) with nbins and histogram limits of min and maxNote - thresholds are not inclusive ie lthresh&lt;allowed&lt;uthresh 6.2 Perform inhomogeneity correction # fsl_biascorrect calls FAST from FSL fast_img = fslr::fsl_biascorrect(nim, retimg=TRUE) ## FSLDIR=&#39;/usr/local/fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/fast -B --nopve --out=&quot;/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T//Rtmp3GNcsB/file2abf41f5c0b9&quot; &quot;/private/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T/Rtmp3GNcsB/file2abfa1c3566.nii.gz&quot;; 6.3 Plot difference between images in R we can use colors to visually inspect the difference between two images. In this case, the bias-corrected image was substracted from the original image and the resulting intensities (i.e. areare colored based on their sign. Quantiles are used to provide to derive the color palette. sub_bias = niftiarr(nim, nim-fast_img) #quantile the difference image using these breaks q = quantile(sub_bias[sub_bias != 0], probs = seq(0,1,0.1)) #install.packages(&quot;scales&quot;) library(scales) #get a gradient palette to map onto divergence between images fcol = scales::div_gradient_pal(low=&quot;blue&quot;, mid=&quot;yellow&quot;, high=&quot;red&quot;) ortho2(nim, sub_bias, col.y=alpha(fcol(seq(0,1, length = 10))), #color for second arg ybreaks= q, ycolorbar= TRUE, text = paste0(&quot;Original Image Minus N4&quot;, &quot;\\n Bias-Corrected Image&quot;) ) 6.4 Plotting histograms of intensities for original and bias-corrected images # choose a subset of slices to be plotted slices = c(2,6,10,14,18) # for each slice number save that slice from the original and bias-corrected images into an array vals = lapply(slices, function(x){ cbind(img = c(nim[,,x]), fast = c(fast_img[,,x]), slice = x) }) # row bind all elements of the vals list to get a data.frame vals = do.call(&quot;rbind&quot;, vals) vals = data.frame(vals) # filter out values below 0 vals = vals[vals$img &gt; 0 &amp; vals$fast &gt; 0,] # Change column names colnames(vals)[1:2] = c(&quot;OriginalValue&quot;, &quot;Bias-Corrected Value&quot;) v = reshape::melt(vals, id.vars = &quot;slice&quot;) library(dplyr) library(ggplot2) g = v %&gt;% ggplot(aes(x = value, col = factor(slice))) + geom_line(stat = &quot;density&quot;) + facet_wrap(~variable) + scale_colour_discrete(name = &quot;Slice #&quot;) g After bias field correction the intensity curves line up better across slice. Also, the relative intensities are affected such that the highest intensity. 6.5 Write NIfTi fname = paste0(&quot;fast-&quot;,fname) suppressMessages(oro.nifti::writeNIfTI(fast_img, file.path(fpath, fname))) "],
["skull-stripping-with-fsls-brain-extraction-tool-bet.html", "Lecture 7 Skull Stripping with FSL’s Brain Extraction Tool (BET) 7.1 Loading file 7.2 Running BET 7.3 Visualizing first past 7.4 Improving Brain Extraction 7.5 Visualizing first and second pass 7.6 Write NIfTI", " Lecture 7 Skull Stripping with FSL’s Brain Extraction Tool (BET) 7.1 Loading file #set fsl path before running fslr in RStudio library(fslr) if(!have.fsl()){ options(fsl.path = &#39;/usr/local/bin&#39;) } #Check file paths for data downloaded from library(oro.nifti) fpath = &quot;Neurohacking_data/kirby21/visit_1/113&quot; fname = &quot;fast-113-01-MPRAGE&quot; fast_img = readNIfTI(file.path(fpath,fname), reorient=FALSE) 7.2 Running BET bet_fast = fslr::fslbet(infile=fast_img, retimg = TRUE) ## FSLDIR=&#39;/usr/local/fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/bet2 &quot;/private/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T/RtmpmusoTp/file2c314bb9976d.nii.gz&quot; &quot;/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T//RtmpmusoTp/file2c311d9f6564&quot; 7.3 Visualizing first past To visualize the effects of the brain extraction on the original, the orthographic may be used twice by passing (1) the image returned by BET, (2) the original image overlaid by a mask. To produce the mask, follow the code below. # create an array of 1s with same dimensions as the skull-stripped image bet_fast_mask = niftiarr(bet_fast, 1) # set all non-brain voxel to NA bet_fast_mask[!(bet_fast &gt; 0)] &lt;- NA # plot orthographic(bet_fast) orthographic(fast_img, bet_fast_mask) The results are not great since a lot of non-brain areas get included. 7.4 Improving Brain Extraction To improve upon the results, a second pass can be done taking into account the center of gravity. # use the cog function on the skull-stripped image cog = cog(bet_fast, ceil = TRUE) #prepare a string to be passed to opts parameter of fslbet cog = paste(&quot;-c&quot;, paste(cog, collapse = &quot; &quot;)) # run BET on the bias-corrected img using the center of gravity to get cleaner results bet_fast2 = fslbet(infile = fast_img, retimg = TRUE, opts = cog) ## FSLDIR=&#39;/usr/local/fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/bet2 &quot;/private/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T/RtmpmusoTp/file2c314582822.nii.gz&quot; &quot;/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T//RtmpmusoTp/file2c313a31728f&quot; -c 88 140 129 7.5 Visualizing first and second pass orthographic(bet_fast) orthographic(bet_fast2) The results have improved, removing much of the lower non-brain sections. However, we can see the results are not perfect so it’s important to visually inspect each image at each phase of the processing pipeline. 7.6 Write NIfTI fname = paste0(&quot;bet2-&quot;,fname) suppressMessages(oro.nifti::writeNIfTI(bet_fast2, file.path(fpath, fname))) "],
["registration-to-a-template-spatial-normalization.html", "Lecture 8 Registration to a template (Spatial Normalization) 8.1 Linear Registration", " Lecture 8 Registration to a template (Spatial Normalization) 8.1 Linear Registration FSL’s FMRIB’s Linear Image Registration Tool (FLIRT) implements rigid and affine transformation to the the image 8.1.1 Read files library(oro.nifti) ## oro.nifti 0.10.1 temp_dir = &quot;Neurohacking_data/Template&quot; template_img = oro.nifti::readNIfTI(file.path(temp_dir, &quot;MNI152_T1_1mm_brain.nii.gz&quot;), reorient = FALSE) fpath = &quot;Neurohacking_data/kirby21/visit_1/113&quot; fname = &quot;bet2-fast-113-01-MPRAGE&quot; bet2_fast_img = oro.nifti::readNIfTI(file.path(fpath, fname), reorient = FALSE) orthographic(bet2_fast_img) 8.1.2 Running FLIRT for rigid transformation register_img = fslr::flirt(infile = bet2_fast_img, reffile = template_img, dof = 6, #for rigid transformation retimg = TRUE) ## Warning in get.fsl(): Setting fsl.path to /usr/local/fsl ## Warning in get.fsloutput(): Can&#39;t find FSLOUTPUTTYPE, setting to NIFTI_GZ ## FSLDIR=&#39;/usr/local/fsl&#39;; PATH=${FSLDIR}/bin:${PATH};export PATH FSLDIR; sh &quot;${FSLDIR}/etc/fslconf/fsl.sh&quot;; FSLOUTPUTTYPE=NIFTI_GZ; export FSLOUTPUTTYPE; ${FSLDIR}/bin/flirt -in &quot;/private/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T/RtmpBiaW4A/file2dfa598620f5.nii.gz&quot; -ref &quot;/private/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T/RtmpBiaW4A/file2dfa74dde2bd.nii.gz&quot; -out &quot;/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T//RtmpBiaW4A/file2dfa4f283844&quot; -dof 6 -omat &quot;/var/folders/wk/jzm8xd01507b9nx7qmycj7700000gn/T//RtmpBiaW4A/file2dfa1351223c.mat&quot; orthographic(template_img) orthographic(register_img) "]
]
